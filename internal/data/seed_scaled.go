// Copyright 2026 Phillip Cloud
// Licensed under the Apache License, Version 2.0

package data

import (
	"crypto/sha256"
	"fmt"
	"time"

	"github.com/cpcloud/webcasa/internal/fake"
)

// SeedSummary holds counts of generated entities for display after seeding.
type SeedSummary struct {
	Vendors     int
	Projects    int
	Quotes      int
	Appliances  int
	Maintenance int
	Incidents   int
	ServiceLogs int
	Documents   int
}

// SeedScaledData populates the database with years of simulated home ownership
// data using a fixed seed for deterministic output. Skips if data already exists.
func (s *Store) SeedScaledData(years int) (SeedSummary, error) {
	return s.SeedScaledDataFrom(fake.New(42), years)
}

// SeedScaledDataFrom populates the database with scaled demo data generated by
// the given HomeFaker. The years parameter controls how many years of
// simulated home ownership to generate.
func (s *Store) SeedScaledDataFrom(h *fake.HomeFaker, years int) (SeedSummary, error) {
	var summary SeedSummary

	var count int64
	if err := s.db.Model(&HouseProfile{}).Count(&count).Error; err != nil {
		return summary, fmt.Errorf("check existing data: %w", err)
	}
	if count > 0 {
		return summary, nil
	}

	// Phase 1: house profile.
	fh := h.HouseProfile()
	house := HouseProfile{
		Nickname:         fh.Nickname,
		AddressLine1:     fh.AddressLine1,
		City:             fh.City,
		State:            fh.State,
		PostalCode:       fh.PostalCode,
		YearBuilt:        fh.YearBuilt,
		SquareFeet:       fh.SquareFeet,
		LotSquareFeet:    fh.LotSquareFeet,
		Bedrooms:         fh.Bedrooms,
		Bathrooms:        fh.Bathrooms,
		FoundationType:   fh.FoundationType,
		WiringType:       fh.WiringType,
		RoofType:         fh.RoofType,
		ExteriorType:     fh.ExteriorType,
		HeatingType:      fh.HeatingType,
		CoolingType:      fh.CoolingType,
		WaterSource:      fh.WaterSource,
		SewerType:        fh.SewerType,
		ParkingType:      fh.ParkingType,
		BasementType:     fh.BasementType,
		InsuranceCarrier: fh.InsuranceCarrier,
		InsurancePolicy:  fh.InsurancePolicy,
		InsuranceRenewal: fh.InsuranceRenewal,
		PropertyTaxCents: fh.PropertyTaxCents,
		HOAName:          fh.HOAName,
		HOAFeeCents:      fh.HOAFeeCents,
	}
	if err := s.db.Create(&house).Error; err != nil {
		return summary, fmt.Errorf("seed house: %w", err)
	}

	// Lookup helpers that panic on missing seed data. SeedDefaults must run
	// before this function; a missing type/category is a programming error.
	typeID := func(name string) uint {
		var pt ProjectType
		if err := s.db.Where(ColName+" = ?", name).First(&pt).Error; err != nil {
			panic(fmt.Sprintf(
				"seed: project type %q not found (run SeedDefaults first): %v",
				name, err,
			))
		}
		return pt.ID
	}
	catID := func(name string) uint {
		var mc MaintenanceCategory
		if err := s.db.Where(ColName+" = ?", name).First(&mc).Error; err != nil {
			panic(fmt.Sprintf(
				"seed: maintenance category %q not found (run SeedDefaults first): %v",
				name, err,
			))
		}
		return mc.ID
	}

	// Track used vendor names to avoid unique constraint violations.
	usedVendorNames := make(map[string]bool)
	createVendor := func(v *Vendor) error {
		// Disambiguate if the name is already taken.
		base := v.Name
		for attempt := 2; usedVendorNames[v.Name]; attempt++ {
			v.Name = fmt.Sprintf("%s %d", base, attempt)
		}
		usedVendorNames[v.Name] = true
		return s.db.Create(v).Error
	}

	// Phase 2: base entity pool (year 0).
	trades := fake.VendorTrades()
	vendors := make([]Vendor, 0, 10)
	for i := 0; i < 10 && i < len(trades); i++ {
		fv := h.VendorForTrade(trades[i])
		v := Vendor{
			Name:        fv.Name,
			ContactName: fv.ContactName,
			Phone:       fv.Phone,
			Email:       fv.Email,
		}
		if err := createVendor(&v); err != nil {
			return summary, fmt.Errorf("seed vendor %s: %w", v.Name, err)
		}
		vendors = append(vendors, v)
	}
	summary.Vendors = len(vendors)

	projectTypeNames := fake.ProjectTypes()
	projects := make([]Project, 0, 5)
	for i := 0; i < 5; i++ {
		typeName := projectTypeNames[i%len(projectTypeNames)]
		fp := h.Project(typeName)
		fp.Status = projectStatusForAge(h, years)
		p := Project{
			Title:         fp.Title,
			ProjectTypeID: typeID(typeName),
			Status:        fp.Status,
			Description:   fp.Description,
			StartDate:     fp.StartDate,
			EndDate:       fp.EndDate,
			BudgetCents:   fp.BudgetCents,
			ActualCents:   fp.ActualCents,
		}
		if err := s.db.Create(&p).Error; err != nil {
			return summary, fmt.Errorf("seed project %s: %w", p.Title, err)
		}
		projects = append(projects, p)
	}
	summary.Projects = len(projects)

	appliances := make([]Appliance, 0, 8)
	for i := 0; i < 8; i++ {
		fa := h.Appliance()
		a := Appliance{
			Name:           fa.Name,
			Brand:          fa.Brand,
			ModelNumber:    fa.ModelNumber,
			SerialNumber:   fa.SerialNumber,
			Location:       fa.Location,
			PurchaseDate:   fa.PurchaseDate,
			WarrantyExpiry: fa.WarrantyExpiry,
			CostCents:      fa.CostCents,
		}
		if err := s.db.Create(&a).Error; err != nil {
			return summary, fmt.Errorf("seed appliance %s: %w", a.Name, err)
		}
		appliances = append(appliances, a)
	}
	summary.Appliances = len(appliances)

	categoryNames := fake.MaintenanceCategories()
	maintItems := make([]MaintenanceItem, 0, 20)
	for _, catName := range categoryNames {
		nItems := 2 + h.IntN(2) // 2-3 per category
		for j := 0; j < nItems; j++ {
			fm := h.MaintenanceItem(catName)
			item := MaintenanceItem{
				Name:           fm.Name,
				CategoryID:     catID(catName),
				IntervalMonths: fm.IntervalMonths,
				Notes:          fm.Notes,
				LastServicedAt: fm.LastServicedAt,
				CostCents:      fm.CostCents,
			}
			if catName == "Appliance" || catName == "HVAC" {
				ai := h.IntN(len(appliances))
				item.ApplianceID = &appliances[ai].ID
			}
			if err := s.db.Create(&item).Error; err != nil {
				return summary, fmt.Errorf("seed maintenance %s: %w", item.Name, err)
			}
			maintItems = append(maintItems, item)
		}
	}
	summary.Maintenance = len(maintItems)

	// Base incidents.
	incidents := make([]Incident, 0, 3)
	for i := 0; i < 3; i++ {
		fi := h.Incident()
		inc := Incident{
			Title:       fi.Title,
			Description: fi.Description,
			Status:      fi.Status,
			Severity:    fi.Severity,
			DateNoticed: fi.DateNoticed,
			Location:    fi.Location,
			CostCents:   fi.CostCents,
		}
		if len(appliances) > 0 && h.IntN(2) == 0 {
			inc.ApplianceID = &appliances[h.IntN(len(appliances))].ID
		}
		if len(vendors) > 0 && h.IntN(2) == 0 {
			inc.VendorID = &vendors[h.IntN(len(vendors))].ID
		}
		if err := s.db.Create(&inc).Error; err != nil {
			return summary, fmt.Errorf("seed incident %s: %w", inc.Title, err)
		}
		incidents = append(incidents, inc)
	}
	summary.Incidents = len(incidents)

	// Base quotes for eligible year-0 projects.
	quotes := seedQuotesForProjects(h, projects, vendors)
	for i := range quotes {
		if err := s.db.Create(&quotes[i]).Error; err != nil {
			return summary, fmt.Errorf("seed quote: %w", err)
		}
	}
	summary.Quotes = len(quotes)

	// Base documents for year-0 entities.
	docs := seedBaseDocuments(projects, appliances, incidents)
	for i := range docs {
		if err := s.db.Create(&docs[i]).Error; err != nil {
			return summary, fmt.Errorf("seed document %s: %w", docs[i].Title, err)
		}
	}
	summary.Documents = len(docs)

	// Phase 3: year-by-year growth loop.
	// Simulate from (currentYear - years + 1) through currentYear.
	currentYear := time.Now().Year()
	startYear := currentYear - years + 1

	var allServiceLogs []ServiceLogEntry

	for yr := startYear; yr <= currentYear; yr++ {
		yearsAgo := currentYear - yr

		// Generate service logs for all existing maintenance items this year.
		for mi := range maintItems {
			logs := serviceLogsForYear(h, &maintItems[mi], vendors, yr)
			allServiceLogs = append(allServiceLogs, logs...)
		}

		// Add 1-2 new vendors per year.
		nNewVendors := 1 + h.IntN(2)
		for i := 0; i < nNewVendors; i++ {
			fv := h.Vendor()
			v := Vendor{
				Name:        fv.Name,
				ContactName: fv.ContactName,
				Phone:       fv.Phone,
				Email:       fv.Email,
				Website:     fv.Website,
			}
			if err := createVendor(&v); err != nil {
				return summary, fmt.Errorf("seed vendor %s: %w", v.Name, err)
			}
			vendors = append(vendors, v)
			summary.Vendors++
		}

		// Add 2-4 new projects per year.
		nNewProjects := 2 + h.IntN(3)
		for i := 0; i < nNewProjects; i++ {
			typeName := projectTypeNames[h.IntN(len(projectTypeNames))]
			fp := h.Project(typeName)
			fp.Status = projectStatusForAge(h, yearsAgo)
			p := Project{
				Title:         fp.Title,
				ProjectTypeID: typeID(typeName),
				Status:        fp.Status,
				Description:   fp.Description,
				StartDate:     fp.StartDate,
				EndDate:       fp.EndDate,
				BudgetCents:   fp.BudgetCents,
				ActualCents:   fp.ActualCents,
			}
			if err := s.db.Create(&p).Error; err != nil {
				return summary, fmt.Errorf("seed project %s: %w", p.Title, err)
			}
			projects = append(projects, p)
			summary.Projects++
		}

		// Quotes for newly added projects this year.
		startIdx := len(projects) - nNewProjects
		newProjects := projects[startIdx:]
		newQuotes := seedQuotesForProjects(h, newProjects, vendors)
		for i := range newQuotes {
			if err := s.db.Create(&newQuotes[i]).Error; err != nil {
				return summary, fmt.Errorf("seed quote: %w", err)
			}
		}
		summary.Quotes += len(newQuotes)

		// Add 0-2 new appliances per year.
		nNewAppliances := h.IntN(3)
		for i := 0; i < nNewAppliances; i++ {
			fa := h.Appliance()
			a := Appliance{
				Name:           fa.Name,
				Brand:          fa.Brand,
				ModelNumber:    fa.ModelNumber,
				SerialNumber:   fa.SerialNumber,
				Location:       fa.Location,
				PurchaseDate:   fa.PurchaseDate,
				WarrantyExpiry: fa.WarrantyExpiry,
				CostCents:      fa.CostCents,
			}
			if err := s.db.Create(&a).Error; err != nil {
				return summary, fmt.Errorf("seed appliance %s: %w", a.Name, err)
			}
			appliances = append(appliances, a)
			summary.Appliances++
		}

		// Add 1-3 new maintenance items per year (capped at 50 total).
		if len(maintItems) < 50 {
			nNewMaint := 1 + h.IntN(3)
			for i := 0; i < nNewMaint && len(maintItems) < 50; i++ {
				catName := categoryNames[h.IntN(len(categoryNames))]
				fm := h.MaintenanceItem(catName)
				item := MaintenanceItem{
					Name:           fm.Name,
					CategoryID:     catID(catName),
					IntervalMonths: fm.IntervalMonths,
					Notes:          fm.Notes,
					LastServicedAt: fm.LastServicedAt,
					CostCents:      fm.CostCents,
				}
				if (catName == "Appliance" || catName == "HVAC") && len(appliances) > 0 {
					ai := h.IntN(len(appliances))
					item.ApplianceID = &appliances[ai].ID
				}
				if err := s.db.Create(&item).Error; err != nil {
					return summary, fmt.Errorf("seed maintenance %s: %w", item.Name, err)
				}
				maintItems = append(maintItems, item)
				summary.Maintenance++
			}
		}

		// Add 1-2 incidents per year.
		nNewIncidents := 1 + h.IntN(2)
		for i := 0; i < nNewIncidents; i++ {
			fi := h.Incident()
			inc := Incident{
				Title:       fi.Title,
				Description: fi.Description,
				Status:      fi.Status,
				Severity:    fi.Severity,
				DateNoticed: fi.DateNoticed,
				Location:    fi.Location,
				CostCents:   fi.CostCents,
			}
			if len(appliances) > 0 && h.IntN(3) == 0 {
				inc.ApplianceID = &appliances[h.IntN(len(appliances))].ID
			}
			if len(vendors) > 0 && h.IntN(3) == 0 {
				inc.VendorID = &vendors[h.IntN(len(vendors))].ID
			}
			if err := s.db.Create(&inc).Error; err != nil {
				return summary, fmt.Errorf("seed incident %s: %w", inc.Title, err)
			}
			incidents = append(incidents, inc)
			summary.Incidents++
		}

		// Add 5-10 documents per year across various entity types.
		nNewDocs := 5 + h.IntN(6)
		for i := 0; i < nNewDocs; i++ {
			doc := randomDocument(h, projects, appliances, maintItems, vendors, incidents)
			if err := s.db.Create(&doc).Error; err != nil {
				return summary, fmt.Errorf("seed document %s: %w", doc.Title, err)
			}
			summary.Documents++
		}
	}

	// Phase 4: batch insert accumulated service logs.
	if len(allServiceLogs) > 0 {
		if err := s.db.CreateInBatches(&allServiceLogs, 500).Error; err != nil {
			return summary, fmt.Errorf("seed service logs: %w", err)
		}
		summary.ServiceLogs = len(allServiceLogs)
	}

	return summary, nil
}

// projectStatusForAge returns a project status weighted by how old the project
// is. Older projects are more likely to be completed.
func projectStatusForAge(h *fake.HomeFaker, yearsAgo int) string {
	// Weight completed more heavily for older projects.
	// yearsAgo 0 = current year (any status), 5+ = heavily completed.
	completedWeight := 10 + yearsAgo*15
	if completedWeight > 80 {
		completedWeight = 80
	}

	roll := h.IntN(100)
	switch {
	case roll < completedWeight:
		return ProjectStatusCompleted
	case roll < completedWeight+5:
		return ProjectStatusAbandoned
	case roll < completedWeight+10:
		return ProjectStatusDelayed
	case roll < completedWeight+15:
		return ProjectStatusInProgress
	case roll < completedWeight+20:
		return ProjectStatusQuoted
	case roll < completedWeight+25:
		return ProjectStatusPlanned
	default:
		return ProjectStatusIdeating
	}
}

// serviceLogsForYear generates service log entries for a maintenance item
// during a given year. Entries are spaced evenly based on the item's interval
// with random jitter, and ~15% are skipped to simulate missed services.
func serviceLogsForYear(
	h *fake.HomeFaker,
	item *MaintenanceItem,
	vendors []Vendor,
	year int,
) []ServiceLogEntry {
	if item.IntervalMonths <= 0 {
		return nil
	}
	servicesPerYear := 12 / item.IntervalMonths
	if servicesPerYear < 1 {
		servicesPerYear = 1
	}

	intervalDays := 365 / servicesPerYear
	var logs []ServiceLogEntry

	for i := 0; i < servicesPerYear; i++ {
		// Skip ~15% to simulate missed services.
		if h.IntN(100) < 15 {
			continue
		}

		baseDayOfYear := i*intervalDays + intervalDays/2
		// Add jitter of +/- 7 days.
		jitter := h.IntN(15) - 7
		dayOfYear := baseDayOfYear + jitter
		if dayOfYear < 1 {
			dayOfYear = 1
		}
		if dayOfYear > 365 {
			dayOfYear = 365
		}

		servicedAt := time.Date(year, time.January, 1, 0, 0, 0, 0, time.UTC).
			AddDate(0, 0, dayOfYear-1)

		fe := h.ServiceLogEntryAt(servicedAt)
		entry := ServiceLogEntry{
			MaintenanceItemID: item.ID,
			ServicedAt:        fe.ServicedAt,
			CostCents:         fe.CostCents,
			Notes:             fe.Notes,
		}

		// ~30% chance to link to a vendor.
		if h.IntN(10) < 3 && len(vendors) > 0 {
			vi := h.IntN(len(vendors))
			entry.VendorID = &vendors[vi].ID
		}

		logs = append(logs, entry)
	}

	return logs
}

// seedQuotesForProjects generates 1-2 quotes for each non-ideating,
// non-abandoned project.
func seedQuotesForProjects(
	h *fake.HomeFaker,
	projects []Project,
	vendors []Vendor,
) []Quote {
	var quotes []Quote
	for i := range projects {
		if projects[i].Status == ProjectStatusIdeating ||
			projects[i].Status == ProjectStatusAbandoned {
			continue
		}
		nQuotes := 1 + h.IntN(2)
		for q := 0; q < nQuotes; q++ {
			vi := h.IntN(len(vendors))
			fq := h.Quote()
			quotes = append(quotes, Quote{
				ProjectID:      projects[i].ID,
				VendorID:       vendors[vi].ID,
				TotalCents:     fq.TotalCents,
				LaborCents:     fq.LaborCents,
				MaterialsCents: fq.MaterialsCents,
				ReceivedDate:   fq.ReceivedDate,
				Notes:          fq.Notes,
			})
		}
	}
	return quotes
}

// seedBaseDocuments creates initial documents for the first projects, appliances, and incidents.
func seedBaseDocuments(
	projects []Project,
	appliances []Appliance,
	incidents []Incident,
) []Document {
	type docSeed struct {
		title, fileName, mime, kind string
		entityID                    uint
	}

	var seeds []docSeed
	if len(projects) >= 2 {
		seeds = append(
			seeds,
			docSeed{
				"Invoice",
				"invoice.pdf",
				"application/pdf",
				DocumentEntityProject,
				projects[0].ID,
			},
			docSeed{
				"Contract",
				"contract.pdf",
				"application/pdf",
				DocumentEntityProject,
				projects[1].ID,
			},
		)
	}
	if len(appliances) >= 2 {
		seeds = append(
			seeds,
			docSeed{
				"Warranty Card",
				"warranty-card.jpg",
				"image/jpeg",
				DocumentEntityAppliance,
				appliances[0].ID,
			},
			docSeed{
				"User Manual",
				"user-manual.pdf",
				"application/pdf",
				DocumentEntityAppliance,
				appliances[1].ID,
			},
		)
	}
	if len(incidents) >= 1 {
		seeds = append(
			seeds,
			docSeed{
				"Incident Photo",
				"incident-photo.jpg",
				"image/jpeg",
				DocumentEntityIncident,
				incidents[0].ID,
			},
		)
	}

	docs := make([]Document, 0, len(seeds))
	for _, ds := range seeds {
		content := []byte(ds.title + " placeholder content")
		docs = append(docs, Document{
			Title:          ds.title,
			FileName:       ds.fileName,
			EntityKind:     ds.kind,
			EntityID:       ds.entityID,
			MIMEType:       ds.mime,
			SizeBytes:      int64(len(content)),
			ChecksumSHA256: fmt.Sprintf("%x", sha256.Sum256(content)),
			Data:           content,
		})
	}
	return docs
}

var documentTemplates = []struct {
	title    string
	fileName string
	mime     string
}{
	{"Invoice", "invoice.pdf", "application/pdf"},
	{"Receipt", "receipt.pdf", "application/pdf"},
	{"Contract", "contract.pdf", "application/pdf"},
	{"Warranty Card", "warranty-card.pdf", "application/pdf"},
	{"User Manual", "manual.pdf", "application/pdf"},
	{"Inspection Report", "inspection.pdf", "application/pdf"},
	{"Photo", "photo.jpg", "image/jpeg"},
	{"Estimate", "estimate.pdf", "application/pdf"},
	{"Permit", "permit.pdf", "application/pdf"},
	{"Insurance Claim", "claim.pdf", "application/pdf"},
}

// randomDocument creates a document linked to a random entity.
func randomDocument(
	h *fake.HomeFaker,
	projects []Project,
	appliances []Appliance,
	maintItems []MaintenanceItem,
	vendors []Vendor,
	incidents []Incident,
) Document {
	tmpl := documentTemplates[h.IntN(len(documentTemplates))]
	content := []byte(tmpl.title + " placeholder content")

	doc := Document{
		Title:          tmpl.title,
		FileName:       tmpl.fileName,
		MIMEType:       tmpl.mime,
		SizeBytes:      int64(len(content)),
		ChecksumSHA256: fmt.Sprintf("%x", sha256.Sum256(content)),
		Data:           content,
	}

	// Link to a random entity type.
	switch h.IntN(5) {
	case 0:
		if len(projects) > 0 {
			doc.EntityKind = DocumentEntityProject
			doc.EntityID = projects[h.IntN(len(projects))].ID
		}
	case 1:
		if len(appliances) > 0 {
			doc.EntityKind = DocumentEntityAppliance
			doc.EntityID = appliances[h.IntN(len(appliances))].ID
		}
	case 2:
		if len(maintItems) > 0 {
			doc.EntityKind = DocumentEntityMaintenance
			doc.EntityID = maintItems[h.IntN(len(maintItems))].ID
		}
	case 3:
		if len(vendors) > 0 {
			doc.EntityKind = DocumentEntityVendor
			doc.EntityID = vendors[h.IntN(len(vendors))].ID
		}
	case 4:
		if len(incidents) > 0 {
			doc.EntityKind = DocumentEntityIncident
			doc.EntityID = incidents[h.IntN(len(incidents))].ID
		}
	}

	return doc
}
