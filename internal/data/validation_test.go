// Copyright 2026 Phillip Cloud
// Licensed under the Apache License, Version 2.0

package data

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestParseRequiredCents(t *testing.T) {
	tests := []struct {
		input string
		want  int64
	}{
		{"100", 10000},
		{"100.5", 10050},
		{"100.05", 10005},
		{"$1,234.56", 123456},
		{".75", 75},
		{"0.99", 99},
	}
	for _, test := range tests {
		got, err := ParseRequiredCents(test.input)
		require.NoError(t, err, "input=%q", test.input)
		assert.Equal(t, test.want, got, "input=%q", test.input)
	}
}

func TestParseRequiredCentsInvalid(t *testing.T) {
	for _, input := range []string{"", "12.345", "abc", "1.2.3"} {
		_, err := ParseRequiredCents(input)
		assert.Error(t, err, "input=%q", input)
	}
}

func TestParseOptionalCents(t *testing.T) {
	value, err := ParseOptionalCents("")
	require.NoError(t, err)
	assert.Nil(t, value)

	value, err = ParseOptionalCents("5")
	require.NoError(t, err)
	require.NotNil(t, value)
	assert.Equal(t, int64(500), *value)
}

func TestFormatCents(t *testing.T) {
	assert.Equal(t, "$1,234.56", FormatCents(123456))
}

func TestParseOptionalDate(t *testing.T) {
	date, err := ParseOptionalDate("2025-06-11")
	require.NoError(t, err)
	require.NotNil(t, date)
	assert.Equal(t, "2025-06-11", date.Format(DateLayout))

	_, err = ParseOptionalDate("06/11/2025")
	assert.Error(t, err)
}

func TestParseOptionalInt(t *testing.T) {
	value, err := ParseOptionalInt("12")
	require.NoError(t, err)
	assert.Equal(t, 12, value)

	_, err = ParseOptionalInt("-1")
	assert.Error(t, err)
}

func TestParseOptionalFloat(t *testing.T) {
	value, err := ParseOptionalFloat("2.5")
	require.NoError(t, err)
	assert.Equal(t, 2.5, value)

	_, err = ParseOptionalFloat("-1.2")
	assert.Error(t, err)
}

func TestFormatOptionalCents(t *testing.T) {
	assert.Empty(t, FormatOptionalCents(nil))
	cents := int64(123456)
	assert.Equal(t, "$1,234.56", FormatOptionalCents(&cents))
}

func TestFormatCentsNegative(t *testing.T) {
	assert.Equal(t, "-$5.00", FormatCents(-500))
}

func TestFormatCentsZero(t *testing.T) {
	assert.Equal(t, "$0.00", FormatCents(0))
}

func TestParseRequiredDate(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{"2025-06-11", "2025-06-11"},
		{" 2025-06-11 ", "2025-06-11"},
	}
	for _, tt := range tests {
		got, err := ParseRequiredDate(tt.input)
		require.NoError(t, err, "input=%q", tt.input)
		assert.Equal(t, tt.want, got.Format(DateLayout), "input=%q", tt.input)
	}
}

func TestParseRequiredDateInvalid(t *testing.T) {
	for _, input := range []string{"", "06/11/2025", "not-a-date", "2025-13-01"} {
		_, err := ParseRequiredDate(input)
		assert.Error(t, err, "input=%q", input)
	}
}

func TestFormatDate(t *testing.T) {
	assert.Empty(t, FormatDate(nil))
	d := time.Date(2025, 6, 11, 0, 0, 0, 0, time.UTC)
	assert.Equal(t, "2025-06-11", FormatDate(&d))
}

func TestParseRequiredInt(t *testing.T) {
	tests := []struct {
		input string
		want  int
	}{
		{"42", 42},
		{" 7 ", 7},
		{"0", 0},
	}
	for _, tt := range tests {
		got, err := ParseRequiredInt(tt.input)
		require.NoError(t, err, "input=%q", tt.input)
		assert.Equal(t, tt.want, got, "input=%q", tt.input)
	}
}

func TestParseRequiredIntInvalid(t *testing.T) {
	for _, input := range []string{"", "abc", "-5", "1.5"} {
		_, err := ParseRequiredInt(input)
		assert.Error(t, err, "input=%q", input)
	}
}

func TestParseRequiredFloat(t *testing.T) {
	tests := []struct {
		input string
		want  float64
	}{
		{"2.5", 2.5},
		{" 0 ", 0},
		{"100", 100},
	}
	for _, tt := range tests {
		got, err := ParseRequiredFloat(tt.input)
		require.NoError(t, err, "input=%q", tt.input)
		assert.Equal(t, tt.want, got, "input=%q", tt.input)
	}
}

func TestParseRequiredFloatInvalid(t *testing.T) {
	for _, input := range []string{"", "abc", "-1.5"} {
		_, err := ParseRequiredFloat(input)
		assert.Error(t, err, "input=%q", input)
	}
}

func TestParseOptionalIntEmpty(t *testing.T) {
	got, err := ParseOptionalInt("")
	require.NoError(t, err)
	assert.Zero(t, got)
}

func TestParseOptionalFloatEmpty(t *testing.T) {
	got, err := ParseOptionalFloat("")
	require.NoError(t, err)
	assert.Zero(t, got)
}

func TestParseOptionalDateEmpty(t *testing.T) {
	got, err := ParseOptionalDate("")
	require.NoError(t, err)
	assert.Nil(t, got)
}

func TestParseOptionalCentsInvalid(t *testing.T) {
	_, err := ParseOptionalCents("abc")
	assert.Error(t, err)
}

func TestComputeNextDue(t *testing.T) {
	last := time.Date(2024, 10, 10, 0, 0, 0, 0, time.UTC)
	next := ComputeNextDue(&last, 6)
	require.NotNil(t, next)
	assert.Equal(t, "2025-04-10", next.Format(DateLayout))
}

func TestComputeNextDueNilDate(t *testing.T) {
	assert.Nil(t, ComputeNextDue(nil, 6))
}

func TestComputeNextDueZeroInterval(t *testing.T) {
	d := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	assert.Nil(t, ComputeNextDue(&d, 0))
}

func TestFormatCompactCents(t *testing.T) {
	tests := []struct {
		name  string
		cents int64
		want  string
	}{
		{"zero", 0, "$0.00"},
		{"small", 999, "$9.99"},
		{"hundred", 10000, "$100.00"},
		{"just under 1k", 99999, "$999.99"},
		{"exactly 1k", 100000, "$1k"},
		{"1.2k", 123456, "$1.2k"},
		{"round thousands", 4500000, "$45k"},
		{"thousands with decimal", 5234023, "$52.3k"},
		{"exactly 1M", 100000000, "$1M"},
		{"1.3M", 130000000, "$1.3M"},
		{"round millions", 200000000, "$2M"},
		{"negative small", -500, "-$5.00"},
		{"negative thousands", -250000, "-$2.5k"},
		{"negative millions", -100000000, "-$1M"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, FormatCompactCents(tt.cents))
		})
	}
}

func TestFormatCompactOptionalCents(t *testing.T) {
	assert.Empty(t, FormatCompactOptionalCents(nil))
	cents := int64(250000)
	assert.Equal(t, "$2.5k", FormatCompactOptionalCents(&cents))
}
